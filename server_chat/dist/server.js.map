{
  "version": 3,
  "sources": ["../server_def.js"],
  "sourcesContent": ["import express from \"express\";\nimport axios from \"axios\";\nimport dotenv from \"dotenv\";\nimport cors from \"cors\";\nimport fs from \"fs\";\nimport path from \"path\";\nimport crypto from \"crypto\";\nimport { fileURLToPath } from \"url\";\n\n// ES modules compatibility\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\ndotenv.config();\nconst app = express();\napp.use(express.json());\napp.use(cors());\n\n// === CONFIG ===\nconst OPENROUTER_URL = \"https://openrouter.ai/api/v1/chat/completions\";\nconst CHATS_DIR = path.join(__dirname, \"..\", \"chats\"); // Directory condivisa per i file utente\nconst LOG_JSON_PATH = path.join(__dirname, \"..\", \"chats\", \"responses.json\"); // Log globale nella stessa dir\n\n// Crea la cartella se non esiste\nif (!fs.existsSync(CHATS_DIR)) {\n  fs.mkdirSync(CHATS_DIR);\n}\n\n// ========== UTIL: Canonicalizzazione (JCS-like) ==========\nfunction canonicalize(value) {\n  // JSON Canonicalization Scheme-like: chiavi ordinate, niente spazi\n  if (value === null || typeof value !== \"object\") return value;\n  if (Array.isArray(value)) return value.map(canonicalize);\n  const sorted = {};\n  for (const k of Object.keys(value).sort()) {\n    sorted[k] = canonicalize(value[k]);\n  }\n  return sorted;\n}\nfunction toCanonicalJSONString(obj) {\n  const canon = canonicalize(obj);\n  // stringify senza spazi: separators = (\",\", \":\")\n  return JSON.stringify(canon);\n}\n\n// ========== UTIL: Hash ==========\nconst DOMAIN_PREFIX = Buffer.from(\"MSGv1|\"); // domain separation\nfunction sha256HexFromCanonical(canonicalJSONString) {\n  const h = crypto.createHash(\"sha256\");\n  h.update(DOMAIN_PREFIX);\n  h.update(Buffer.from(canonicalJSONString, \"utf8\"));\n  return h.digest(\"hex\");\n}\n\n// ========== UTIL: FHE placeholder ==========\nfunction fheEncryptPlaceholder(hashHex) {\n  // Placeholder leggibile/deterministico (NON sicuro!) per integrazione end-to-end.\n  // In produzione: usa TFHE/Concrete con chiavi reali del cliente.\n  const salt = crypto.createHash(\"sha256\").update(\"tfhe-demo\").digest();\n  const x = Buffer.from(hashHex, \"hex\");\n  const xor = Buffer.alloc(x.length);\n  for (let i = 0; i < x.length; i++) xor[i] = x[i] ^ salt[i % salt.length];\n  return \"FHE_CTXT_\" + xor.toString(\"hex\").slice(0, 64);\n}\n\n// ========== UTIL: Merkle Tree (SHA-256 su concat left||right) ==========\nfunction merkleParentHex(leftHex, rightHex) {\n  const h = crypto.createHash(\"sha256\");\n  const left = Buffer.from(leftHex, \"hex\");\n  const right = Buffer.from((rightHex ?? leftHex), \"hex\"); // se dispari, duplica l'ultima\n  h.update(Buffer.concat([left, right]));\n  return h.digest(\"hex\");\n}\nfunction buildMerkleTree(leavesHex) {\n  if (leavesHex.length === 0) {\n    return { root: null, levels: [] };\n  }\n  let level = [...leavesHex];\n  const levels = [level];\n  while (level.length > 1) {\n    const next = [];\n    for (let i = 0; i < level.length; i += 2) {\n      const left = level[i];\n      const right = i + 1 < level.length ? level[i + 1] : null;\n      next.push(merkleParentHex(left, right ?? left));\n    }\n    level = next;\n    levels.push(level);\n  }\n  return { root: levels[levels.length - 1][0], levels };\n}\nfunction merkleProofForIndex(levels, index) {\n  // levels[0] = foglie, levels[last] = root level\n  const proof = [];\n  let idx = index;\n  for (let depth = 0; depth < levels.length - 1; depth++) {\n    const level = levels[depth];\n    const isRight = idx % 2 === 1;\n    const siblingIndex = isRight ? idx - 1 : idx + 1;\n    const siblingHash = level[siblingIndex] ?? level[idx]; // duplica se manca\n    proof.push({ pos: isRight ? \"left\" : \"right\", h: siblingHash });\n    idx = Math.floor(idx / 2);\n  }\n  return proof;\n}\n\n// ========== UTIL: Data windows ==========\nfunction yyyymmddUTCFromUnixSeconds(sec) {\n  const d = new Date(sec * 1000);\n  const y = d.getUTCFullYear();\n  const m = String(d.getUTCMonth() + 1).padStart(2, \"0\");\n  const day = String(d.getUTCDate()).padStart(2, \"0\");\n  return `${y}-${m}-${day}`;\n}\n\n// === FUNZIONI DI SUPPORTO ===\n\n// Carica il file JSON completo dell'utente (chat + log + archivio)\nfunction loadUserFile(user_id) {\n  const userFile = path.join(CHATS_DIR, `chats_${user_id}.json`);\n  if (fs.existsSync(userFile)) {\n    try {\n      const parsed = JSON.parse(fs.readFileSync(userFile, \"utf8\"));\n      \n      // MIGRAZIONE: converti vecchio formato (chats flat) in conversations\n      if (parsed.chats && !parsed.conversations) {\n        const conversations = [];\n        if (parsed.chats.length > 0) {\n          // Strategia di separazione intelligente:\n          // Separa conversazioni solo quando ci sono \"pause\" logiche\n          // Indizi di nuova conversazione:\n          // 1. Due messaggi user consecutivi (significa che non c'\u00E8 stata risposta)\n          // 2. Cambio drastico di topic (difficile da rilevare, quindi usiamo euristica)\n          \n          let currentConv = { \n            id: '1', \n            title: '', \n            messages: [], \n            createdAt: new Date().toISOString(), \n            updatedAt: new Date().toISOString() \n          };\n          let convId = 1;\n          \n          for (let i = 0; i < parsed.chats.length; i++) {\n            const msg = parsed.chats[i];\n            const prevMsg = currentConv.messages[currentConv.messages.length - 1];\n            \n            // Nuova conversazione SOLO se:\n            // - \u00C8 un messaggio user\n            // - E il messaggio precedente era anche user (no risposta in mezzo)\n            const shouldStartNewConv = \n              msg.role === 'user' && \n              prevMsg && \n              prevMsg.role === 'user';\n            \n            if (shouldStartNewConv) {\n              // Salva conversazione corrente\n              if (currentConv.messages.length > 0) {\n                const firstUserMsg = currentConv.messages.find(m => m.role === 'user');\n                currentConv.title = firstUserMsg ? \n                  firstUserMsg.content.slice(0, 40) + (firstUserMsg.content.length > 40 ? '...' : '') : \n                  'Chat ' + convId;\n                conversations.push(currentConv);\n              }\n              // Inizia nuova conversazione\n              convId++;\n              currentConv = { \n                id: String(convId), \n                title: '', \n                messages: [], \n                createdAt: new Date().toISOString(), \n                updatedAt: new Date().toISOString() \n              };\n            }\n            \n            currentConv.messages.push(msg);\n          }\n          \n          // Aggiungi l'ultima conversazione\n          if (currentConv.messages.length > 0) {\n            const firstUserMsg = currentConv.messages.find(m => m.role === 'user');\n            currentConv.title = firstUserMsg ? \n              firstUserMsg.content.slice(0, 40) + (firstUserMsg.content.length > 40 ? '...' : '') : \n              'Chat ' + convId;\n            conversations.push(currentConv);\n          }\n        }\n        \n        parsed.conversations = conversations;\n        delete parsed.chats;\n        saveUserFile(user_id, parsed);\n      }\n      \n      // garantisci campi\n      return {\n        conversations: parsed.conversations ?? [],\n        logs: parsed.logs ?? [],\n        messages: parsed.messages ?? [],       // archivio per messaggi indicizzati\n        trees: parsed.trees ?? {}              // per tree_id -> { leaves, root, algo, canon_rules }\n      };\n    } catch (err) {\n      console.warn(`\u26A0\uFE0F Errore caricando file chat per ${user_id}:`, err.message);\n      return { conversations: [], logs: [], messages: [], trees: {} };\n    }\n  } else {\n    return { conversations: [], logs: [], messages: [], trees: {} };\n  }\n}\n\n// Salva il file JSON completo dell\u2019utente\nfunction saveUserFile(user_id, data) {\n  const userFile = path.join(CHATS_DIR, `chats_${user_id}.json`);\n  fs.writeFileSync(userFile, JSON.stringify(data, null, 2), \"utf8\");\n}\n\n// Gestione log globale (responses.json)\nlet logs = [];\nif (fs.existsSync(LOG_JSON_PATH)) {\n  try {\n    logs = JSON.parse(fs.readFileSync(LOG_JSON_PATH, \"utf8\"));\n  } catch {\n    logs = [];\n  }\n}\nfunction saveGlobalLog(entry) {\n  logs.push(entry);\n  fs.writeFileSync(LOG_JSON_PATH, JSON.stringify(logs, null, 2), \"utf8\");\n}\n\n// ========== PIPE: costruzione archivio + merkle ==========\nfunction createMessageArchiveEntry({ user_id, created, provider, model, content, system_fingerprint, content_type }) {\n  const nonce = crypto.randomBytes(5).toString(\"hex\");\n\n  // payload minimo + nonce + (opzionale) content_type per distinguere user/assistant\n  const payload = {\n    user_id,\n    created,\n    provider,\n    model,\n    content,\n    system_fingerprint,\n    nonce\n  };\n  if (content_type) payload.content_type = content_type; // opzionale ma utile\n\n  const canonical_json = toCanonicalJSONString(payload);\n  const content_hash = sha256HexFromCanonical(canonical_json);\n  const content_hash_fhe = fheEncryptPlaceholder(content_hash);\n\n  return {\n    user_id,\n    created,\n    provider,\n    model,\n    content,\n    system_fingerprint,\n    nonce,\n    ...(content_type ? { content_type } : {}),\n    content_hash,\n    content_hash_fhe,\n    canonical_json\n  };\n}\n\nfunction upsertMerkleAndAnnotate(userData, archiveEntry) {\n  const tree_id = yyyymmddUTCFromUnixSeconds(archiveEntry.created);\n  if (!userData.trees[tree_id]) {\n    userData.trees[tree_id] = {\n      algo: \"SHA-256\",\n      canon_rules: \"JCS-like\",\n      leaves: [],   // array di content_hash in ordine d\u2019inserimento\n      root: null\n    };\n  }\n  const tree = userData.trees[tree_id];\n\n  // Append nuova foglia\n  const leaf_index = tree.leaves.length;\n  tree.leaves.push(archiveEntry.content_hash);\n\n  // Ricostruisci l\u2019albero (semplice e robusto)\n  const { root, levels } = buildMerkleTree(tree.leaves);\n\n  tree.root = root;\n\n  // Calcola la proof per questa foglia\n  const proof = merkleProofForIndex(levels, leaf_index);\n\n  // Oggetto completo come da specifica\n  const stored = {\n    content_hash: archiveEntry.content_hash,\n    content_hash_fhe: archiveEntry.content_hash_fhe,\n    canonical_json: archiveEntry.canonical_json,\n    tree_id,\n    leaf_index,\n    proof\n  };\n\n  return { stored, tree_id };\n}\n\n// === FUNZIONE PRINCIPALE INVIO AI ===\nasync function sendToAI(user_id, provider, model, newMessage, conversation_id = null) {\n  const userData = loadUserFile(user_id);\n\n  console.log('\uD83D\uDD35 sendToAI - Ricevuto conversation_id:', conversation_id);\n  console.log('\uD83D\uDD35 sendToAI - Conversazioni esistenti:', userData.conversations.map(c => ({ id: c.id, messages: c.messages.length })));\n\n  // Trova o crea la conversazione\n  let conversation;\n  if (conversation_id) {\n    conversation = userData.conversations.find(c => c.id === conversation_id);\n    if (!conversation) {\n      // Conversazione non trovata, crea nuova con l'ID specificato\n      console.log('\u26A0\uFE0F  Conversation ID non trovato, creo nuova conversazione con ID:', conversation_id);\n      conversation = {\n        id: conversation_id,\n        title: newMessage.slice(0, 40) + (newMessage.length > 40 ? '...' : ''),\n        messages: [],\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString()\n      };\n      userData.conversations.push(conversation);\n    } else {\n      console.log('\u2705 Trovata conversazione esistente:', conversation_id, '- Messaggi attuali:', conversation.messages.length);\n    }\n  } else {\n    // Nessun ID fornito, crea nuova conversazione con timestamp\n    const newId = Date.now().toString();\n    console.log('\uD83C\uDD95 Nessun conversation_id fornito, creo nuova con ID:', newId);\n    conversation = {\n      id: newId,\n      title: newMessage.slice(0, 40) + (newMessage.length > 40 ? '...' : ''),\n      messages: [],\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString()\n    };\n    userData.conversations.push(conversation);\n  }\n\n  // Aggiungi messaggio utente alla conversazione\n  console.log('\uD83D\uDCDD Aggiunto messaggio utente alla conversazione:', conversation.id);\n  conversation.messages.push({ role: \"user\", content: newMessage });\n  conversation.updatedAt = new Date().toISOString();\n\n  const response = await axios.post(\n    OPENROUTER_URL,\n    { model, messages: conversation.messages },\n    {\n      headers: {\n        Authorization: `Bearer ${process.env.OPENROUTER_API_KEY}`,\n        \"HTTP-Referer\": \"http://localhost:3000\",\n        \"X-Title\": provider,\n        \"Content-Type\": \"application/json\",\n      },\n    }\n  );\n\n  const data = response.data;\n  const aiMessage = data.choices?.[0]?.message?.content || \"\";\n  const created = (typeof data.created === \"number\" ? data.created : Math.floor(Date.now() / 1000)); // UNIX sec\n  const system_fingerprint = data.system_fingerprint || \"none\";\n\n  // Aggiungi risposta AI alla conversazione\n  conversation.messages.push({ role: \"assistant\", content: aiMessage });\n  conversation.updatedAt = new Date().toISOString();\n\n  // Log \"classico\"\n  const logEntry = {\n    user_id,\n    created,\n    provider,\n    model,\n    message: newMessage,\n    response: aiMessage,\n    system_fingerprint,\n  };\n\n  // === Archivio: indicizza MESSAGGIO UTENTE ===\n  const archiveUser = createMessageArchiveEntry({\n    user_id,\n    created,\n    provider,\n    model,\n    content: newMessage,\n    system_fingerprint,\n    content_type: \"user\"\n  });\n  const { stored: storedUsr, tree_id: treeIdUsr } = upsertMerkleAndAnnotate(userData, archiveUser);\n\n  userData.messages.push({\n    ...archiveUser,\n    tree_id: treeIdUsr,\n    leaf_index: storedUsr.leaf_index,\n    proof: storedUsr.proof\n  });\n\n  // === Archivio: indicizza RISPOSTA ASSISTENTE ===\n  const archiveAssistant = createMessageArchiveEntry({\n    user_id,\n    created, // puoi anche usare Date.now()/1000 se vuoi distinguere temporalmente\n    provider,\n    model,\n    content: aiMessage,\n    system_fingerprint,\n    content_type: \"assistant\"\n  });\n  const { stored: storedAsst, tree_id: treeIdAsst } = upsertMerkleAndAnnotate(userData, archiveAssistant);\n\n  userData.messages.push({\n    ...archiveAssistant,\n    tree_id: treeIdAsst,\n    leaf_index: storedAsst.leaf_index,\n    proof: storedAsst.proof\n  });\n\n  // Salvataggi\n  userData.logs.push(logEntry);\n  saveUserFile(user_id, userData);\n  saveGlobalLog(logEntry);\n\n  console.log('\uD83D\uDCBE Salvata conversazione:', conversation.id, '- Totale messaggi:', conversation.messages.length);\n  console.log('\uD83D\uDCCA Totale conversazioni utente:', userData.conversations.length);\n\n  // Risultato per il client\n  return {\n    aiMessage,\n    full_response: data,\n    created,\n    system_fingerprint,\n    conversation_id: conversation.id  // Restituisci l'ID conversazione\n  };\n}\n\n// === ENDPOINT CHAT ===\napp.post(\"/api/chat\", async (req, res) => {\n  try {\n    const {\n      user_id = \"anonymous\",\n      provider = \"OpenAI\",\n      model = \"gpt-4o-mini\",\n      message,\n      conversation_id = null,  // Nuovo: ID conversazione opzionale\n    } = req.body;\n\n    console.log('\uD83D\uDD35 /api/chat - Ricevuto dal frontend:', {\n      user_id,\n      conversation_id,\n      conversation_id_type: typeof conversation_id,\n      message: message?.substring(0, 30)\n    });\n\n    if (!message || typeof message !== \"string\") {\n      return res.status(400).json({ error: \"Campo 'message' mancante o non valido\" });\n    }\n\n    const result = await sendToAI(user_id, provider, model, message, conversation_id);\n\n    res.json({\n      success: true,\n      provider,\n      model,\n      content: result.aiMessage,\n      created: result.created,\n      system_fingerprint: result.system_fingerprint,\n      conversation_id: result.conversation_id,  // Restituisci l'ID conversazione\n    });\n  } catch (err) {\n    console.error(\"\u274C Errore generico chat:\", err.response?.data || err.message);\n    res.status(500).json({ error: err.message, details: err.response?.data });\n  }\n});\n\n// === ENDPOINT PER OTTENERE LE CHAT/LOG/ARCHIVI E TREES DI UN UTENTE ===\napp.get(\"/api/chats/:user_id\", (req, res) => {\n  const { user_id } = req.params;\n  const userData = loadUserFile(user_id);\n\n  // Calcola \u201Cview\u201D sintetica per l\u2019albero pi\u00F9 recente (opzionale)\n  let latestTree = null;\n  const treeIds = Object.keys(userData.trees).sort();\n  if (treeIds.length > 0) {\n    const lastId = treeIds[treeIds.length - 1];\n    const t = userData.trees[lastId];\n    latestTree = {\n      tree_id: lastId,\n      root_hash: t.root,\n      algo: t.algo,\n      canon_rules: t.canon_rules,\n      total_leaves: t.leaves.length\n    };\n  }\n\n  res.json({\n    user_id,\n    conversations: userData.conversations,  // Nuovo formato\n    logs: userData.logs,\n    // archivio dei messaggi con hash, ciphertext FHE (placeholder), proof, ecc.\n    messages: userData.messages,\n    // stato dei merkle tree (per ogni finestra giornaliera)\n    trees: Object.fromEntries(\n      Object.entries(userData.trees).map(([id, t]) => [\n        id,\n        {\n            root: t.root,\n            root_hash: t.root, \n            algo: t.algo, \n            canon_rules: t.canon_rules,\n            leaves: t.leaves,               //per ricpotruire la proof lato client\n            leaves_count: t.leaves.length \n        }\n      ])\n    ),\n    latest_tree: latestTree\n  });\n});\n\n// === ENDPOINT: proof on-demand per una leaf ===\napp.get(\"/api/proof/:user_id/:hash\", (req, res) => {\n  const { user_id, hash } = req.params;\n  const userData = loadUserFile(user_id);\n\n  // cerca in quale albero sta questa leaf\n  for (const [tree_id, t] of Object.entries(userData.trees)) {\n    const idx = t.leaves.indexOf(hash);\n    if (idx !== -1) {\n      // ricostruisci livelli e proof\n      const { root, levels } = buildMerkleTree(t.leaves);\n      const proof = merkleProofForIndex(levels, idx);\n      return res.json({\n        user_id,\n        tree_id,\n        leaf_hash: hash,\n        leaf_index: idx,\n        root_hash: root,\n        algo: t.algo,\n        canon_rules: t.canon_rules,\n        domain_prefix: \"MSGv1|\",\n        proof\n      });\n    }\n  }\n  res.status(404).json({ error: \"hash non trovato in nessun albero\" });\n});\n\n// === ENDPOINT SPECIFICI PER PROVIDER ===\nconst providerConfigs = {\n  openai: \"openai/gpt-4o-mini\",\n  anthropic: \"anthropic/claude-haiku-4.5\",\n  xai: \"x-ai/grok-4-fast\",\n  google: \"google/gemini-2.5-flash-preview-09-2025\",\n  meta: \"meta-llama/llama-3.1-70b-instruct\",\n};\n\nObject.entries(providerConfigs).forEach(([providerName, model]) => {\n  app.post(`/api/${providerName}`, async (req, res) => {\n    try {\n      const { \n        user_id = \"anonymous\", \n        message,\n        conversation_id = null  // \u2B05\uFE0F AGGIUNTO: supporto conversation_id\n      } = req.body;\n\n      console.log(`\uD83D\uDD35 /api/${providerName} - Ricevuto:`, {\n        user_id,\n        conversation_id,\n        message: message?.substring(0, 30)\n      });\n\n      if (!message || typeof message !== \"string\") {\n        return res.status(400).json({ error: \"Campo 'message' mancante o non valido\" });\n      }\n\n      const result = await sendToAI(user_id, providerName, model, message, conversation_id);  // \u2B05\uFE0F PASSA conversation_id\n      res.json({\n        success: true,\n        provider: providerName,\n        model,\n        content: result.aiMessage,\n        created: result.created,\n        system_fingerprint: result.system_fingerprint,\n        conversation_id: result.conversation_id,  // \u2B05\uFE0F AGGIUNTO: restituisci conversation_id\n      });\n    } catch (err) {\n      console.error(`\u274C Errore ${providerName}:`, err.response?.data || err.message);\n      res.status(500).json({ error: err.message, details: err.response?.data });\n    }\n  });\n});\n\n// === ENDPOINT: Recupera lo storico chat dell'utente ===\napp.get('/api/user-chats/:userId', (req, res) => {\n  try {\n    const { userId } = req.params;\n    \n    if (!userId) {\n      return res.status(400).json({ error: 'userId is required' });\n    }\n\n    // Carica il file JSON dell'utente\n    const userData = loadUserFile(userId);\n    \n    // Restituisci le conversazioni\n    res.json({\n      conversations: userData.conversations || [],\n      success: true\n    });\n  } catch (err) {\n    console.error(`\u274C Error loading chats for user ${req.params.userId}:`, err);\n    res.status(500).json({ \n      error: 'Failed to load chat history',\n      details: err.message \n    });\n  }\n});\n\n// === SERVER ===\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () =>\n  console.log(`\u2705 Server AI multi-utente avviato su http://localhost:${PORT}`)\n);\n"],
  "mappings": "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",
  "names": ["express", "axios", "dotenv", "cors", "fs", "path", "crypto", "fileURLToPath", "__filename", "__dirname", "app", "OPENROUTER_URL", "CHATS_DIR", "LOG_JSON_PATH", "canonicalize", "value", "sorted", "k", "toCanonicalJSONString", "obj", "canon", "DOMAIN_PREFIX", "sha256HexFromCanonical", "canonicalJSONString", "h", "fheEncryptPlaceholder", "hashHex", "salt", "x", "xor", "i", "merkleParentHex", "leftHex", "rightHex", "left", "right", "buildMerkleTree", "leavesHex", "level", "levels", "next", "merkleProofForIndex", "index", "proof", "idx", "depth", "isRight", "siblingIndex", "siblingHash", "yyyymmddUTCFromUnixSeconds", "sec", "d", "y", "m", "day", "loadUserFile", "user_id", "userFile", "parsed", "conversations", "currentConv", "convId", "msg", "prevMsg", "firstUserMsg", "saveUserFile", "err", "data", "logs", "saveGlobalLog", "entry", "createMessageArchiveEntry", "created", "provider", "model", "content", "system_fingerprint", "content_type", "nonce", "payload", "canonical_json", "content_hash", "content_hash_fhe", "upsertMerkleAndAnnotate", "userData", "archiveEntry", "tree_id", "tree", "leaf_index", "root", "sendToAI", "newMessage", "conversation_id", "c", "conversation", "newId", "aiMessage", "logEntry", "archiveUser", "storedUsr", "treeIdUsr", "archiveAssistant", "storedAsst", "treeIdAsst", "req", "res", "message", "result", "latestTree", "treeIds", "lastId", "t", "id", "hash", "providerConfigs", "providerName", "userId", "PORT"]
}
